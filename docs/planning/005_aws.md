# User Story: Disposable GPU Janitor Runner

## Story ID

JNR-001

## Title

Run Janitor maintenance jobs on a disposable GPU EC2 instance via a monorepo one-liner.

## Narrative

**As** a Janitor maintainer  
**I want** to trigger a reproducible AWS GPU instance that runs Janitor against a repo list and then
shuts itself down  
**So that** I can validate & auto-fix Docker repos without using my laptop and without incurring
idle cloud cost.

## Acceptance Criteria

- [ ] **Repo-list source**â€‚Janitor reads repositories from `infra/repos.yaml` committed in the
      monorepo; path is overridable with `REPOS_FILE`.
- [ ] **Layer cache**â€‚Docker build layers persist across runs via a dedicated 50 GiB **gp3 EBS**
      volume attached to the runner and preserved between starts.
- [ ] **One-liner run**â€‚Running `make run-janitor ENV=dev REPOS_FILE=repos.yaml` from the repo root
      must:
    1. Provision (or start) an EC2 **g5.xlarge** instance from the Launch Template.
    2. Pull the latest `janitor` image from ECR.
    3. Execute Janitor **sequentially** against the repo list (no parallelisation).
    4. Upload the JSON report to the `janitor-reports` S3 prefix.
    5. Stop or terminate the instance automatically.
    6. Exit locally with status `0`.
- [ ] **Report retrieval**â€‚`make fetch-report ENV=dev` downloads the most-recent runâ€™s report into
      `reports/`.
- [ ] **Auto-shutdown SLA**â€‚Instance reaches `stopped` or `terminated` within **â‰¤ 5 minutes** of
      Janitor finishing.
- [ ] **CloudWatch logging**â€‚Stdout/stderr of the Janitor container streams to log group
      `/janitor-runner`; run is marked failed if unexpected `ERROR` lines appear.
- [ ] **GPU verification**â€‚Inside the container, `nvidia-smi` (or
      `docker run --gpus all nvidia/cuda:12.4.0-base nvidia-smi`) lists at least one NVIDIA GPU.
- [ ] **Least-privilege IAM**â€‚Instance role allows only:
    - `ecr:GetAuthorizationToken`, `ecr:BatchGetImage`, `ecr:GetDownloadUrlForLayer`
    - `s3:PutObject` to `janitor-reports/*` and `janitor-cache/*`
    - `logs:*` on its own log group
    - `ssm:*` for Systems Manager access.
- [ ] **CI green**â€‚`make ci` (lint + `terraform validate` + `packer validate`) passes in GitHub
      Actions on every PR.
- [ ] **Cost visibility**â€‚Daily AWS Cost Explorer shows â‰¤ $2/day spend in the `janitor`
      cost-allocation tag when idle.

## Definition of Done

- CI workflow validates Terraform and Packer templates on pull request.
- README explains prerequisites and environment variables.
- All modules pass `terraform validate` and `tflint`.
- Packer template builds successfully and AMI appears in AWS console.
- End-to-end run completes and an example report is committed to `examples/`.

---

## Monorepo Layout

""" . â”œâ”€â”€ Makefile â”œâ”€â”€ README.md â”œâ”€â”€ packages/ # Node workspaces â”‚ â””â”€â”€ janitor-agent/ # existing
Mastra-based agent â””â”€â”€ infra/ â”œâ”€â”€ terraform/ â”‚ â”œâ”€â”€ main.tf â”‚ â”œâ”€â”€ variables.tf â”‚ â”œâ”€â”€ outputs.tf â”‚ â””â”€â”€
backend.tf â”œâ”€â”€ packer/ â”‚ â””â”€â”€ gpu-ami.pkr.hcl â”œâ”€â”€ scripts/ â”‚ â”œâ”€â”€ bootstrap.sh â”‚ â””â”€â”€ helpers.sh â”œâ”€â”€
env/ â”‚ â”œâ”€â”€ dev.tfvars â”‚ â””â”€â”€ prod.tfvars â””â”€â”€ repos.yaml # committed repo list """

### Key Components

| Path                         | Purpose                                                                           |
| ---------------------------- | --------------------------------------------------------------------------------- |
| `Makefile`                   | Developer UX; wraps Dockerised `terraform`, `packer`, and AWS CLI.                |
| `infra/terraform`            | Launch template, security groups, IAM roles, S3 buckets, EBS cache volume.        |
| `infra/packer`               | Builds the GPU AMI with Docker & NVIDIA tooling.                                  |
| `infra/scripts/bootstrap.sh` | User-data script; pulls Janitor image, runs job, uploads report, self-terminates. |
| `packages/janitor-agent`     | Janitor code; built to Docker image by Makefile target.                           |

---

## Local Developer Workflow

"""

# 0. Prerequisites

brew install direnv docker make cp .env.example .env # fill in AWS_PROFILE, AWS_REGION, ACCOUNT_ID
direnv allow # exports env vars automatically

# 1. Build Janitor image & push to ECR

make image

# 2. Validate & apply infra

make infra-plan make infra-apply ENV=dev

# 3. Trigger a run (uses AWS SSM to send command)

make run-janitor ENV=dev REPOS_FILE=infra/repos.yaml

# 4. Grab the resulting report

make fetch-report ENV=dev

# 5. Destroy when finished

make destroy ENV=dev """

All `make` targets execute the real tools inside lightweight Docker containers, keeping the host
clean.

---

## CI / CD

- `.github/workflows/ci.yml`â€‚runs `make ci` (lint, unit tests, Terraform validate, Packer validate).
- `.github/workflows/release.yml`â€‚builds the Janitor Docker image and pushes to ECR on release tags.
- `.github/workflows/nightly.yml`â€‚runs `make run-janitor ENV=prod` nightly for full maintenance.

---

## Decisions

| Topic              | Choice                                                     |
| ------------------ | ---------------------------------------------------------- |
| Repo list location | Committed YAML (`infra/repos.yaml`).                       |
| Layer cache        | Persisted EBS volume (50 GiB gp3).                         |
| Execution model    | Sequential runs (no AWS Batch yet) due to LLM rate limits. |

---

### References

- `infra/scripts/bootstrap.sh` â€“ self-terminating pattern.
- `infra/packer/gpu-ami.pkr.hcl` â€“ NVIDIA driver & container toolkit install.
- Terraform uses `miloserdov/ec2-spot-instance` for optional spot capacity.

---

Happy hacking! ðŸš€
